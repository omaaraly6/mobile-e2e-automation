name: Maestro iOS Test on macOS

on:
  workflow_dispatch:
    inputs:
      ipa_artifact_name:
        description: 'Name of the IPA artifact to download'
        required: true
        default: 'ios-pr-build-coffeeberry-112'
      source_repo:
        description: 'Source repository (owner/repo)'
        required: true
        default: 'zeal-io/white-label-apps'
      source_run_id:
        description: 'Source workflow run ID'
        required: true
        default: '16123259003'
      project_name:
        description: 'Project name'
        required: true
        default: 'coffeeberry'
      pr_number:
        description: 'PR number'
        required: true
        default: '796'
      simulator_device:
        description: 'iOS Simulator device to use'
        required: false
        default: 'iPhone 16'

jobs:
  test:
    runs-on: [self-hosted, macOS]
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: latest-stable
          
      - name: Check System Capabilities
        run: |
          echo "üîç Checking macOS runner capabilities..."
          echo "macOS version:"
          sw_vers
          echo "CPU info:"
          sysctl -n machdep.cpu.brand_string
          echo "CPU core count: $(sysctl -n hw.ncpu)"
          echo "Memory info:"
          sysctl -n hw.memsize | awk '{print $1/1024/1024/1024 " GB"}'
          echo "Available space:"
          df -h
          echo "Xcode version:"
          xcodebuild -version
          echo "Available simulators:"
          xcrun simctl list devices available

      - name: Install Homebrew
        run: |
          if command -v brew >/dev/null 2>&1; then
            echo "‚úÖ Homebrew is already installed"
            brew --version
          else
            echo "üì¶ Installing Homebrew..."
            /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
          fi

      - name: Install Facebook IDB
        run: |
          if command -v idb_companion >/dev/null 2>&1; then
            echo "‚úÖ Facebook IDB is already installed"
            idb_companion --version || echo "IDB version check failed (this is normal)"
          else
            echo "üì¶ Installing Facebook IDB..."
            brew install facebook/fb/idb-companion
          fi

      - name: Install Maestro CLI
        run: |
          if command -v maestro >/dev/null 2>&1; then
            echo "‚úÖ Maestro is already installed"
            maestro --version
          else
            echo "üì¶ Installing Maestro CLI..."
            brew tap mobile-dev-inc/tap
            brew install maestro
          fi

      - name: Setup Node.js for Testmo CLI
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install Testmo CLI
        run: |
          if command -v testmo >/dev/null 2>&1; then
            echo "‚úÖ Testmo CLI is already installed"
            testmo --version
          else
            echo "üì¶ Installing Testmo CLI..."
            echo "üîç npm version: $(npm --version)"
            echo "üîç Node.js version: $(node --version)"
            
            # Install with verbose output to catch any issues
            if npm install -g @testmo/testmo-cli; then
              echo "‚úÖ Testmo CLI installation completed"
              echo "üîç Checking installation..."
              which testmo || echo "‚ùå testmo not found in PATH after installation"
              testmo --version || echo "‚ùå testmo command failed"
              echo "üîç PATH: $PATH"
              echo "üîç npm global packages:"
              npm list -g --depth=0 | grep testmo || echo "testmo not found in npm list"
            else
              echo "‚ùå Failed to install Testmo CLI"
              exit 1
            fi
          fi
          
      - name: Set Maestro Timeout Environment Variable
        run: echo "MAESTRO_DRIVER_STARTUP_TIMEOUT=1000000" >> $GITHUB_ENV

      # Note: This step requires TESTMO_URL and TESTMO_TOKEN to be configured as repository secrets
      # TESTMO_URL should be your Testmo instance URL (e.g., https://your-company.testmo.com)
      # TESTMO_TOKEN should be a valid API token from your Testmo instance
      # You may also need to adjust the project-id in the test submission step below
      - name: Setup Testmo Resources
        run: |
          echo "üîß Setting up Testmo resources..."
          # Add git hash field
          testmo automation:resources:add-field --name git --type string \
            --value ${GITHUB_SHA:0:7} --resources resources.json
          
          # Add link back to GitHub Actions run
          RUN_URL="$GITHUB_SERVER_URL/$GITHUB_REPOSITORY/actions/runs/$GITHUB_RUN_ID"
          testmo automation:resources:add-link --name "GitHub Actions" \
            --url "$RUN_URL" --resources resources.json
          
          # Add source repository link if different
          if [ "${{ github.event.inputs.source_repo }}" != "${{ github.repository }}" ]; then
            SOURCE_RUN_URL="https://github.com/${{ github.event.inputs.source_repo }}/actions/runs/${{ github.event.inputs.source_run_id }}"
            testmo automation:resources:add-link --name "Source Build" \
              --url "$SOURCE_RUN_URL" --resources resources.json
          fi
          
          # Add PR link if available
          if [ -n "${{ github.event.inputs.pr_number }}" ]; then
            PR_URL="https://github.com/${{ github.event.inputs.source_repo }}/pull/${{ github.event.inputs.pr_number }}"
            testmo automation:resources:add-link --name "Pull Request" \
              --url "$PR_URL" --resources resources.json
          fi
          
          # Add additional metadata
          testmo automation:resources:add-field --name "simulator_device" --type string \
            --value "${{ github.event.inputs.simulator_device }}" --resources resources.json
          testmo automation:resources:add-field --name "project_name" --type string \
            --value "${{ github.event.inputs.project_name }}" --resources resources.json
          testmo automation:resources:add-field --name "ipa_artifact" --type string \
            --value "${{ github.event.inputs.ipa_artifact_name }}" --resources resources.json
        env:
          TESTMO_URL: ${{ secrets.TESTMO_URL }}
          TESTMO_TOKEN: ${{ secrets.TESTMO_TOKEN }}

      - name: Validate Testmo Configuration
        run: |
          echo "üîç Validating Testmo configuration..."
          echo "======================================="
          
          # Debug: Show if variables are set (but not their values for security)
          echo "üîç Environment variable check:"
          if [ -n "$TESTMO_URL" ]; then
            echo "‚úÖ TESTMO_URL is set (${#TESTMO_URL} characters)"
            echo "üîó URL starts with: $(echo "$TESTMO_URL" | cut -c1-20)..."
          else
            echo "‚ùå TESTMO_URL is not set"
          fi
          
          if [ -n "$TESTMO_TOKEN" ]; then
            echo "‚úÖ TESTMO_TOKEN is set (${#TESTMO_TOKEN} characters)"
            echo "üîë Token starts with: $(echo "$TESTMO_TOKEN" | cut -c1-8)..."
          else
            echo "‚ùå TESTMO_TOKEN is not set"
          fi
          
          echo ""
          echo "üîç Step-by-step validation:"
          
          # Step 1: Check TESTMO_URL
          if [ -z "$TESTMO_URL" ]; then
            echo "‚ùå Step 1 FAILED: TESTMO_URL is not set"
            echo "‚ö†Ô∏è  Test results will not be uploaded to Testmo."
            echo "To enable Testmo integration:"
            echo "1. Go to your repository Settings > Secrets and variables > Actions"
            echo "2. Add TESTMO_URL secret with your Testmo instance URL"
            echo "3. Add TESTMO_TOKEN secret with your API token from Testmo"
            echo "TESTMO_ENABLED=false" >> $GITHUB_ENV
            exit 0
          fi
          echo "‚úÖ Step 1 PASSED: TESTMO_URL is set"
          
          # Step 2: Check TESTMO_TOKEN
          if [ -z "$TESTMO_TOKEN" ]; then
            echo "‚ùå Step 2 FAILED: TESTMO_TOKEN is not set"
            echo "‚ö†Ô∏è  Test results will not be uploaded to Testmo."
            echo "TESTMO_ENABLED=false" >> $GITHUB_ENV
            exit 0
          fi
          echo "‚úÖ Step 2 PASSED: TESTMO_TOKEN is set"
          
          # Step 3: Check Testmo CLI
          echo "üîç Step 3: Testing Testmo CLI..."
          if ! command -v testmo >/dev/null 2>&1; then
            echo "‚ùå Step 3 FAILED: Testmo CLI not found in PATH"
            echo "üîç Debugging info:"
            echo "  PATH: $PATH"
            echo "  which testmo: $(which testmo 2>&1 || echo 'not found')"
            echo "  ls /usr/local/bin/testmo: $(ls -la /usr/local/bin/testmo 2>&1 || echo 'not found')"
            echo "  npm list -g | grep testmo: $(npm list -g 2>/dev/null | grep testmo || echo 'not found')"
            echo "TESTMO_ENABLED=false" >> $GITHUB_ENV
            exit 0
          fi
          echo "‚úÖ Step 3 PASSED: Testmo CLI found at $(which testmo)"
          echo "üìã Testmo version: $(testmo --version 2>/dev/null || echo 'Version check failed')"
          
          # Step 4: Test connection
          echo "üîç Step 4: Testing connection..."
          echo "üåê Testing connection to: $TESTMO_URL"
          
          # Capture both stdout and stderr
          CONNECTION_OUTPUT=$(testmo automation:run:list --instance "$TESTMO_URL" --limit 1 2>&1)
          CONNECTION_EXIT_CODE=$?
          
          if [ $CONNECTION_EXIT_CODE -eq 0 ]; then
            echo "‚úÖ Step 4 PASSED: Testmo connection successful!"
            echo "‚úÖ ALL STEPS PASSED - Enabling Testmo integration"
            echo "TESTMO_ENABLED=true" >> $GITHUB_ENV
          else
            echo "‚ùå Step 4 FAILED: Testmo connection failed (exit code: $CONNECTION_EXIT_CODE)"
            echo "üîç Connection error output:"
            echo "$CONNECTION_OUTPUT"
            echo ""
            echo "üîç Possible issues:"
            echo "  - TESTMO_URL might be incorrect"
            echo "  - TESTMO_TOKEN might be invalid or expired"
            echo "  - Network connectivity issues"
            echo "  - Testmo instance might be down"
            echo "‚ùå VALIDATION FAILED - Disabling Testmo integration"
            echo "TESTMO_ENABLED=false" >> $GITHUB_ENV
          fi
          
          echo "======================================="
        env:
          TESTMO_URL: ${{ secrets.TESTMO_URL }}
          TESTMO_TOKEN: ${{ secrets.TESTMO_TOKEN }}
      
      - name: Debug Input Parameters
        run: |
          echo "üîç Debug Input Parameters:"
          echo "ipa_artifact_name: ${{ github.event.inputs.ipa_artifact_name }}"
          echo "source_repo: ${{ github.event.inputs.source_repo }}"
          echo "source_run_id: ${{ github.event.inputs.source_run_id }}"
          echo "project_name: ${{ github.event.inputs.project_name }}"
          echo "pr_number: ${{ github.event.inputs.pr_number }}"
          echo "simulator_device: ${{ github.event.inputs.simulator_device }}"
      
      - name: Download IPA from source repository
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.CROSS_REPO_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            try {
              console.log('üì• Downloading IPA artifact from source repository...');
              
              // Check which token we're using
              const hasCrossRepoToken = '${{ secrets.CROSS_REPO_TOKEN }}' !== '';
              console.log('üîç Token check - CROSS_REPO_TOKEN exists:', hasCrossRepoToken);
              if (!hasCrossRepoToken) {
                console.log('‚ö†Ô∏è  No CROSS_REPO_TOKEN found - using GITHUB_TOKEN (may not work for cross-repo access)');
              } else {
                console.log('‚úÖ Using CROSS_REPO_TOKEN for cross-repository access');
              }
              
              // Test token permissions
              console.log('üîç Testing token permissions...');
              try {
                const { data: user } = await github.rest.users.getAuthenticated();
                console.log(`‚úÖ Token authenticated as: ${user.login}`);
                
                // Test access to source repository
                const [owner, repo] = '${{ github.event.inputs.source_repo }}'.split('/');
                const { data: sourceRepo } = await github.rest.repos.get({
                  owner: owner,
                  repo: repo
                });
                console.log(`‚úÖ Token has access to source repository: ${sourceRepo.full_name}`);
                
              } catch (permError) {
                console.error('‚ùå Token permission test failed:', permError.message);
                console.error('This indicates the token does not have the required permissions');
              }
              
              // Get the artifact details from the source repository
              const [owner, repo] = '${{ github.event.inputs.source_repo }}'.split('/');
              const runId = '${{ github.event.inputs.source_run_id }}';
              const artifactName = '${{ github.event.inputs.ipa_artifact_name }}';
              
              console.log(`Source: ${owner}/${repo}, Run: ${runId}, Artifact: ${artifactName}`);
              
              // First, verify the workflow run exists
              try {
                const { data: workflowRun } = await github.rest.actions.getWorkflowRun({
                  owner: owner,
                  repo: repo,
                  run_id: runId
                });
                console.log(`‚úÖ Workflow run found: #${workflowRun.id} (${workflowRun.status})`);
                console.log(`Created: ${workflowRun.created_at}`);
                console.log(`Updated: ${workflowRun.updated_at}`);
              } catch (runError) {
                console.error(`‚ùå Workflow run ${runId} not found:`, runError.message);
                throw new Error(`Workflow run ${runId} not found in ${owner}/${repo}`);
              }
              
              // List all artifacts in the workflow run
              console.log('üîç Listing all artifacts in the workflow run...');
              const { data: artifacts } = await github.rest.actions.listWorkflowRunArtifacts({
                owner: owner,
                repo: repo,
                run_id: runId
              });
              
              console.log(`Found ${artifacts.artifacts.length} artifacts:`);
              artifacts.artifacts.forEach(artifact => {
                console.log(`- ${artifact.name} (ID: ${artifact.id}, Size: ${artifact.size_in_bytes} bytes, Created: ${artifact.created_at})`);
              });
              
              // Find the target artifact
              const targetArtifact = artifacts.artifacts.find(artifact => 
                artifact.name === artifactName
              );
              
              if (!targetArtifact) {
                console.error(`‚ùå Artifact '${artifactName}' not found in run ${runId}`);
                console.error('Available artifacts:');
                artifacts.artifacts.forEach(artifact => {
                  console.error(`  - ${artifact.name}`);
                });
                throw new Error(`Artifact '${artifactName}' not found in run ${runId}. Available: ${artifacts.artifacts.map(a => a.name).join(', ')}`);
              }
              
              console.log(`‚úÖ Found artifact: ${targetArtifact.name} (ID: ${targetArtifact.id})`);
              
              // Download the artifact using GitHub API directly
              console.log('üì• Downloading artifact using GitHub API...');
              
              const fs = require('fs');
              const https = require('https');
              
              try {
                // Use the GitHub API to get the download URL
                const { data: artifactData } = await github.rest.actions.downloadArtifact({
                  owner: owner,
                  repo: repo,
                  artifact_id: targetArtifact.id,
                  archive_format: 'zip'
                });
                
                console.log('‚úÖ GitHub API download successful!');
                console.log(`Downloaded ${artifactData.byteLength} bytes`);
                
                // Write the binary data to a file
                fs.writeFileSync('artifact.zip', Buffer.from(artifactData));
                
                // Check what we downloaded
                const stats = fs.statSync('artifact.zip');
                console.log(`Downloaded file size: ${stats.size} bytes`);
                
                if (stats.size < 1000) {
                  // File is too small, likely an error response
                  const content = fs.readFileSync('artifact.zip', 'utf8');
                  console.log('Downloaded content (likely error):', content);
                  throw new Error(`Download failed - got error response: ${content}`);
                }
                
                // Extract the zip file
                console.log('Extracting artifact...');
                const { execSync } = require('child_process');
                execSync('unzip -o artifact.zip', { stdio: 'inherit' });
                execSync('rm artifact.zip', { stdio: 'inherit' });
                
              } catch (apiError) {
                console.error('‚ùå GitHub API download failed:', apiError.message);
                
                // Fallback: try with curl using the CROSS_REPO_TOKEN directly
                console.log('üîÑ Trying curl fallback with direct token...');
                
                try {
                  const { execSync } = require('child_process');
                  
                  // Get the token from the secret directly
                  const crossRepoToken = '${{ secrets.CROSS_REPO_TOKEN }}';
                  console.log(`Using CROSS_REPO_TOKEN: ${crossRepoToken ? crossRepoToken.substring(0, 8) + '...' : 'undefined'}`);
                  
                  const downloadUrl = `https://api.github.com/repos/${owner}/${repo}/actions/artifacts/${targetArtifact.id}/zip`;
                  const curlCommand = `curl -L -H "Authorization: Bearer ${crossRepoToken}" -H "Accept: application/vnd.github.v3+json" -H "User-Agent: GitHub-Actions" "${downloadUrl}" -o artifact.zip`;
                  
                  console.log('Executing curl command with direct token...');
                  execSync(curlCommand, { stdio: 'inherit' });
                  
                  const stats = fs.statSync('artifact.zip');
                  console.log(`Fallback download size: ${stats.size} bytes`);
                  
                  if (stats.size < 1000) {
                    const content = fs.readFileSync('artifact.zip', 'utf8');
                    console.log('Fallback content:', content);
                    throw new Error(`Fallback download also failed: ${content}`);
                  }
                  
                  console.log('Extracting artifact...');
                  execSync('unzip -o artifact.zip', { stdio: 'inherit' });
                  execSync('rm artifact.zip', { stdio: 'inherit' });
                  
                } catch (fallbackError) {
                  console.error('‚ùå All download methods failed:', fallbackError.message);
                  throw new Error(`Failed to download artifact after multiple attempts: ${fallbackError.message}`);
                }
              }
              
              // Find the IPA file or app bundle
              const files = fs.readdirSync('.');
              console.log('Extracted files:', files);
              
              let ipaFile = files.find(file => file.endsWith('.ipa'));
              let appBundle = files.find(file => file.endsWith('.app'));
              
              // If no direct IPA/app found, check for nested archives
              if (!ipaFile && !appBundle) {
                console.log('üîç No direct IPA/app found, checking for nested archives...');
                
                // Look for tar.gz files that might contain the IPA
                const tarGzFiles = files.filter(file => file.endsWith('.tar.gz'));
                console.log(`Found ${tarGzFiles.length} tar.gz files:`, tarGzFiles);
                
                for (const tarGzFile of tarGzFiles) {
                  console.log(`üì¶ Extracting nested archive: ${tarGzFile}`);
                  try {
                    const { execSync } = require('child_process');
                    execSync(`tar -xzf "${tarGzFile}"`, { stdio: 'inherit' });
                    
                    // Check what was extracted
                    const extractedFiles = fs.readdirSync('.');
                    console.log('Files after extraction:', extractedFiles);
                    
                    // Look for IPA/app files again
                    ipaFile = extractedFiles.find(file => file.endsWith('.ipa'));
                    appBundle = extractedFiles.find(file => file.endsWith('.app'));
                    
                    if (ipaFile || appBundle) {
                      console.log(`‚úÖ Found app file in ${tarGzFile}`);
                      break;
                    }
                    
                    // Also check in subdirectories
                    for (const file of extractedFiles) {
                      if (fs.statSync(file).isDirectory()) {
                        console.log(`üîç Checking directory: ${file}`);
                        try {
                          const dirFiles = fs.readdirSync(file);
                          console.log(`Files in ${file}:`, dirFiles);
                          
                          const nestedIpa = dirFiles.find(f => f.endsWith('.ipa'));
                          const nestedApp = dirFiles.find(f => f.endsWith('.app'));
                          
                          if (nestedIpa) {
                            const sourcePath = `${file}/${nestedIpa}`;
                            console.log(`‚úÖ Found IPA in subdirectory: ${sourcePath}`);
                            // Move to root for easier access
                            execSync(`mv "${sourcePath}" .`, { stdio: 'inherit' });
                            ipaFile = nestedIpa;
                            break;
                          } else if (nestedApp) {
                            const sourcePath = `${file}/${nestedApp}`;
                            console.log(`‚úÖ Found App bundle in subdirectory: ${sourcePath}`);
                            // Move to root for easier access
                            execSync(`mv "${sourcePath}" .`, { stdio: 'inherit' });
                            appBundle = nestedApp;
                            break;
                          }
                        } catch (dirError) {
                          console.log(`Could not read directory ${file}:`, dirError.message);
                        }
                      }
                    }
                    
                    if (ipaFile || appBundle) break;
                    
                  } catch (extractError) {
                    console.log(`Failed to extract ${tarGzFile}:`, extractError.message);
                  }
                }
              }
              
              if (ipaFile) {
                console.log(`‚úÖ IPA downloaded: ${ipaFile}`);
                core.setOutput('app-file', ipaFile);
                core.setOutput('app-type', 'ipa');
              } else if (appBundle) {
                console.log(`‚úÖ App bundle downloaded: ${appBundle}`);
                core.setOutput('app-file', appBundle);
                core.setOutput('app-type', 'app');
              } else {
                console.log('‚ùå Still no IPA or App bundle found after extracting nested archives');
                console.log('üìÅ Final directory listing:');
                const finalFiles = fs.readdirSync('.');
                finalFiles.forEach(file => {
                  const stats = fs.statSync(file);
                  console.log(`  ${stats.isDirectory() ? 'DIR' : 'FILE'}: ${file}`);
                });
                throw new Error('No IPA or App bundle file found in downloaded artifact (checked nested archives)');
              }
              
            } catch (error) {
              console.error('‚ùå Failed to download IPA:', error.message);
              console.error('Error details:', error);
              
              // Provide helpful debugging information
              console.log('');
              console.log('üîß Debugging Tips:');
              console.log('1. Check if the source workflow run exists and completed successfully');
              console.log('2. Verify the artifact name matches exactly');
              console.log('3. Ensure the artifact hasn\'t expired (artifacts are deleted after 90 days)');
              console.log('4. Check if the source repository is accessible');
              console.log('');
              console.log('üìã Manual IPA Download Instructions:');
              console.log('1. Go to the source workflow run');
              console.log('2. Download the IPA artifact manually');
              console.log('3. Upload it to this workflow run');
              
              throw error;
            }

      - name: Setup iOS Simulator
        run: |
          echo "üîç Setting up iOS Simulator..."
          
          # Get the simulator device name
          SIMULATOR_DEVICE="${{ github.event.inputs.simulator_device }}"
          echo "üì± Target simulator: $SIMULATOR_DEVICE"
          
          # List available simulators
          echo "üìã Available simulators:"
          xcrun simctl list devices available
          
          # Find the simulator UDID with fallback options
          SIMULATOR_UDID=$(xcrun simctl list devices available | grep "$SIMULATOR_DEVICE" | head -1 | grep -oE '\([A-F0-9-]{36}\)' | tr -d '()')
          
          if [ -z "$SIMULATOR_UDID" ]; then
            echo "‚ö†Ô∏è  Simulator '$SIMULATOR_DEVICE' not found! Trying fallback options..."
            
            # Try fallback devices in order of preference
            FALLBACK_DEVICES=("iPhone 16" "iPhone 16 Pro" "iPhone 15" "iPhone 15 Pro" "iPhone SE (3rd generation)")
            
            for FALLBACK_DEVICE in "${FALLBACK_DEVICES[@]}"; do
              echo "üîç Trying fallback: $FALLBACK_DEVICE"
              SIMULATOR_UDID=$(xcrun simctl list devices available | grep "$FALLBACK_DEVICE" | head -1 | grep -oE '\([A-F0-9-]{36}\)' | tr -d '()')
              if [ -n "$SIMULATOR_UDID" ]; then
                echo "‚úÖ Found fallback simulator: $FALLBACK_DEVICE"
                SIMULATOR_DEVICE="$FALLBACK_DEVICE"
                break
              fi
            done
            
            if [ -z "$SIMULATOR_UDID" ]; then
              echo "‚ùå No suitable iOS simulator found!"
              echo "üìã Available iPhone devices:"
              xcrun simctl list devices available | grep -E '^\s*iPhone'
              echo "üìã Available iPad devices:"
              xcrun simctl list devices available | grep -E '^\s*iPad'
              exit 1
            fi
          fi
          
          echo "‚úÖ Found simulator UDID: $SIMULATOR_UDID"
          echo "SIMULATOR_UDID=$SIMULATOR_UDID" >> $GITHUB_ENV
          
          # Shutdown any running simulators
          echo "üîÑ Shutting down existing simulators..."
          xcrun simctl shutdown all
          
          # Boot the target simulator
          echo "üöÄ Booting simulator..."
          xcrun simctl boot "$SIMULATOR_UDID"
          
          # Wait for simulator to be ready (with multiple detection methods)
          echo "‚è≥ Waiting for simulator to be ready..."
          TIMEOUT=120
          ELAPSED=0
          READY=false
          
          while [ $ELAPSED -lt $TIMEOUT ] && [ "$READY" = false ]; do
            # Method 1: Check boot status
            if xcrun simctl bootstatus "$SIMULATOR_UDID" 2>/dev/null | grep -q "Boot status: Booted"; then
              echo "‚úÖ Simulator booted successfully (bootstatus method) in ${ELAPSED} seconds!"
              READY=true
              break
            fi
            
            # Method 2: Check if simulator is in the booted state
            if xcrun simctl list devices | grep "$SIMULATOR_UDID" | grep -q "(Booted)"; then
              echo "‚úÖ Simulator booted successfully (list devices method) in ${ELAPSED} seconds!"
              READY=true
              break
            fi
            
            # Method 3: Try to get device info (indicates simulator is responsive)
            if [ $ELAPSED -gt 20 ]; then
              if xcrun simctl spawn "$SIMULATOR_UDID" launchctl print system 2>/dev/null | grep -q "com.apple."; then
                echo "‚úÖ Simulator booted successfully (spawn test method) in ${ELAPSED} seconds!"
                READY=true
                break
              fi
            fi
            
            sleep 2
            ELAPSED=$((ELAPSED + 2))
            if [ $((ELAPSED % 20)) -eq 0 ]; then
              echo "‚è≥ Waiting... (${ELAPSED}s/${TIMEOUT}s)"
              echo "üîç Trying multiple detection methods for reliability..."
            fi
          done
          
          if [ "$READY" = false ]; then
            echo "‚ö†Ô∏è  Boot detection timed out after ${TIMEOUT} seconds"
            echo "üîç Final simulator status check:"
            xcrun simctl list devices | grep "$SIMULATOR_UDID" || echo "Simulator not found in list"
            echo "üìã Detailed bootstatus output:"
            xcrun simctl bootstatus "$SIMULATOR_UDID" || echo "Bootstatus command failed"
            
            # In CI, we can't prompt user, so check if simulator might be ready anyway
            if xcrun simctl list devices | grep "$SIMULATOR_UDID" | grep -q "(Booted)"; then
              echo "‚úÖ Simulator appears to be booted according to device list - continuing..."
            else
              echo "‚ùå Simulator failed to boot properly"
              exit 1
            fi
          fi
          
          echo "‚úÖ Simulator is ready!"
          xcrun simctl bootstatus "$SIMULATOR_UDID"

      - name: Create test script
        run: |
          cat > test_script.sh << 'EOF'
          #!/bin/bash
          set -e
          
          # Function to run commands with timeout (macOS compatible)
          run_with_timeout() {
            local timeout_duration=$1
            shift
            
            # Start the command in background
            "$@" &
            local cmd_pid=$!
            
            # Wait for the specified timeout
            local elapsed=0
            while [ $elapsed -lt $timeout_duration ]; do
              if ! kill -0 $cmd_pid 2>/dev/null; then
                # Process finished
                wait $cmd_pid
                return $?
              fi
              sleep 1
              elapsed=$((elapsed + 1))
            done
            
            # Timeout reached, kill the process
            echo "‚ùå Command timed out after $timeout_duration seconds: $*"
            kill $cmd_pid 2>/dev/null
            return 1
          }
          
          echo "üîç Looking for iOS app file..."
          IPA_FILE=$(find . -name "*.ipa" | head -1)
          APP_BUNDLE=$(find . -name "*.app" | head -1)
          
          if [ -n "$IPA_FILE" ]; then
            APP_FILE="$IPA_FILE"
            APP_TYPE="ipa"
          elif [ -n "$APP_BUNDLE" ]; then
            APP_FILE="$APP_BUNDLE"
            APP_TYPE="app"
          else
            echo "‚ùå No iOS app file found!"
            echo "üìÅ Current directory contents:"
            ls -la
            exit 1
          fi
          
          echo "üì± Installing iOS app: $APP_FILE (type: $APP_TYPE)"
          
          # Validate app file
          APP_SIZE=$(ls -lh "$APP_FILE" | awk '{print $5}')
          echo "üìä App file size: $APP_SIZE"
          
          # Check if file is too small (likely corrupted)
          APP_BYTES=$(stat -f%z "$APP_FILE")
          if [ "$APP_BYTES" -lt 1000000 ]; then
            echo "‚ö†Ô∏è  WARNING: App file is very small (${APP_SIZE}) - may be corrupted"
          fi
          
          # Check file type
          FILE_TYPE=$(file "$APP_FILE")
          echo "üìã File type: $FILE_TYPE"
          
          # Check simulator status
          echo "üîç Checking simulator status..."
          if [ -n "$SIMULATOR_UDID" ]; then
            echo "üì± Simulator UDID: $SIMULATOR_UDID"
            xcrun simctl bootstatus "$SIMULATOR_UDID"
          else
            echo "‚ùå No simulator UDID found!"
            exit 1
          fi
          
          # Uninstall any previous version first
          echo "üóëÔ∏è Uninstalling previous version..."
          xcrun simctl uninstall "$SIMULATOR_UDID" com.zeal.coffeeberry || echo "No previous installation found"
          
          # Install app
          echo "üì¶ Installing app (this may take a few minutes)..."
          INSTALL_START=$(date +%s)
          
          if run_with_timeout 300 xcrun simctl install "$SIMULATOR_UDID" "$APP_FILE"; then
            INSTALL_END=$(date +%s)
            INSTALL_TIME=$((INSTALL_END - INSTALL_START))
            echo "‚úÖ App installed successfully in ${INSTALL_TIME} seconds"
          else
            echo "‚ùå App installation failed!"
            echo "üìã Checking simulator status..."
            xcrun simctl bootstatus "$SIMULATOR_UDID"
            exit 1
          fi
          
          # Verify installation
          echo "üîç Checking if app was installed..."
          sleep 2
          
          INSTALLED_APPS=$(xcrun simctl listapps "$SIMULATOR_UDID" | grep -i coffeeberry || echo "")
          if [ -n "$INSTALLED_APPS" ]; then
            echo "‚úÖ App found: $INSTALLED_APPS"
          else
            echo "‚ùå App not found after installation!"
            echo "üìã All installed apps:"
            xcrun simctl listapps "$SIMULATOR_UDID" | head -20
            exit 1
          fi
          
          # Launch the app to verify it works
          echo "üöÄ Testing app launch..."
          xcrun simctl launch "$SIMULATOR_UDID" com.zeal.coffeeberry || echo "‚ö†Ô∏è  App launch test failed (this might be normal)"
          
          # Grant permissions that might be needed
          echo "üîê Granting permissions..."
          xcrun simctl privacy "$SIMULATOR_UDID" grant location com.zeal.coffeeberry || echo "Location permission failed"
          xcrun simctl privacy "$SIMULATOR_UDID" grant camera com.zeal.coffeeberry || echo "Camera permission failed"
          xcrun simctl privacy "$SIMULATOR_UDID" grant photos com.zeal.coffeeberry || echo "Photos permission failed"
          
          echo "üìã Checking available flows..."
          echo "üìÅ Current directory structure:"
          ls -la
          echo "üìÅ iOS directory structure:"
          ls -la ios/
          echo "üìÅ Ordering apps directory:"
          ls -la ios/ordering_apps/
          echo "üìã Config file contents:"
          cat ios/ordering_apps/config.yaml
          echo "üìã Available test files:"
          find ios/ordering_apps/ -name "*.yaml" -type f
          
          # Create directory for test results
          mkdir -p test-results
          
          echo "üß™ Running Maestro ordering app flows..."
          echo "üìç Running from current directory: $(pwd)"
          
          # Change to the ordering_apps directory for proper relative paths
          cd ios/ordering_apps/
          echo "üìç Now in directory: $(pwd)"
          echo "üìã Files in current directory:"
          ls -la
          
          # Set exit status tracking
          OVERALL_EXIT_CODE=0
          
          # Try with config file first (using relative paths)
          if maestro test . --config config.yaml --format junit --output ../../test-results/maestro-junit.xml; then
            echo "‚úÖ Tests completed successfully with config"
          else
            echo "‚ö†Ô∏è  Config-based execution failed, trying without config..."
            # If config fails, try without it but still generate JUnit output
            if maestro test . --format junit --output ../../test-results/maestro-junit.xml; then
              echo "‚úÖ Tests completed successfully without config"
            else
              echo "‚ùå Directory-based execution failed, trying individual flows..."
              echo "üìã Running individual flows:"
              
              # Initialize JUnit XML for individual flows
              cat > ../../test-results/maestro-junit.xml << 'JUNIT_EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <testsuites name="Maestro iOS Tests" tests="0" failures="0" errors="0" time="0">
          JUNIT_EOF
              
              TEST_COUNT=0
              FAILURE_COUNT=0
              TOTAL_TIME=0
              
              # Run flows in the order specified in config
              for flow in login/login.yaml pickup_ordering/pickupordering.yaml pickup_ordering/cancelorder.yaml delivery_ordering/deliveryordering.yaml delivery_ordering/cancelorder.yaml login/logout.yaml; do
                if [ -f "$flow" ]; then
                  echo "üß™ Running flow: $flow"
                  TEST_START=$(date +%s)
                  
                  if maestro test "$flow" --format junit --output "../../test-results/$(basename "$flow" .yaml)-junit.xml"; then
                    echo "‚úÖ Flow passed: $flow"
                  else
                    echo "‚ùå Flow failed: $flow"
                    FAILURE_COUNT=$((FAILURE_COUNT + 1))
                    OVERALL_EXIT_CODE=1
                  fi
                  
                  TEST_END=$(date +%s)
                  TEST_TIME=$((TEST_END - TEST_START))
                  TOTAL_TIME=$((TOTAL_TIME + TEST_TIME))
                  TEST_COUNT=$((TEST_COUNT + 1))
                else
                  echo "‚ö†Ô∏è  Flow not found: $flow"
                  FAILURE_COUNT=$((FAILURE_COUNT + 1))
                  OVERALL_EXIT_CODE=1
                fi
              done
              
              # Update the summary in JUnit XML
              sed -i '' "s/tests=\"0\"/tests=\"$TEST_COUNT\"/" ../../test-results/maestro-junit.xml
              sed -i '' "s/failures=\"0\"/failures=\"$FAILURE_COUNT\"/" ../../test-results/maestro-junit.xml
              sed -i '' "s/time=\"0\"/time=\"$TOTAL_TIME\"/" ../../test-results/maestro-junit.xml
              echo "</testsuites>" >> ../../test-results/maestro-junit.xml
            fi
          fi
          
          # Return to original directory
          cd ../../
          
          # Ensure we have test results
          if [ ! -f "test-results/maestro-junit.xml" ]; then
            echo "‚ö†Ô∏è  No JUnit XML found, creating basic results file..."
            mkdir -p test-results
            cat > test-results/maestro-junit.xml << 'JUNIT_EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <testsuites name="Maestro iOS Tests" tests="1" failures="1" errors="0" time="0">
            <testsuite name="MaestroTests" tests="1" failures="1" errors="0" time="0">
              <testcase name="TestExecution" classname="MaestroTests" time="0">
                <failure message="No test results generated">Test execution did not produce valid results</failure>
              </testcase>
            </testsuite>
          </testsuites>
          JUNIT_EOF
          fi
          
          echo "üìä Test results summary:"
          echo "üìÅ Test results directory:"
          ls -la test-results/
          
          if [ -f "test-results/maestro-junit.xml" ]; then
            echo "üìã JUnit XML content preview:"
            head -20 test-results/maestro-junit.xml
          fi
          
          exit $OVERALL_EXIT_CODE
          EOF
          chmod +x test_script.sh

      - name: Run Maestro Tests
        run: |
          echo "üöÄ Running Maestro tests..."
          
          # Run the test script and capture exit code, but don't fail the step
          set +e  # Don't exit on error
          ./test_script.sh
          TEST_EXIT_CODE=$?
          set -e  # Re-enable exit on error
          
          echo "üìä Test execution completed with exit code: $TEST_EXIT_CODE"
          
          # Store the exit code for later steps
          echo "TEST_EXIT_CODE=$TEST_EXIT_CODE" >> $GITHUB_ENV
          
          # Show test results summary
          if [ -f "test-results/maestro-junit.xml" ]; then
            echo "‚úÖ Test results generated successfully"
            echo "üìã Test result files:"
            ls -la test-results/
          else
            echo "‚ö†Ô∏è  No test results found in test-results/"
          fi
        timeout-minutes: 25

      - name: Submit Results to Testmo
        if: always() && env.TESTMO_ENABLED == 'true'
        run: |
          echo "üìä Submitting test results to Testmo..."
          echo "üîç Debug info:"
          echo "  - TESTMO_ENABLED: $TESTMO_ENABLED"
          echo "  - TESTMO_URL length: ${#TESTMO_URL}"
          echo "  - TESTMO_TOKEN length: ${#TESTMO_TOKEN}"
          
          # Check if we have test results to submit
          echo "üîç Checking for test result files..."
          if [ ! -f "test-results/maestro-junit.xml" ]; then
            echo "‚ùå No maestro-junit.xml found to submit to Testmo"
            echo "üìÅ Current directory contents:"
            ls -la
            if [ -d "test-results" ]; then
              echo "üìÅ Test results directory contents:"
              ls -la test-results/
            else
              echo "‚ùå test-results directory doesn't exist"
            fi
            exit 1
          fi
          
          # Show what we're submitting
          echo "‚úÖ Found test results file"
          echo "üìã Test result files to submit:"
          ls -la test-results/*.xml
          
          echo "üìÑ Preview of maestro-junit.xml:"
          head -10 test-results/maestro-junit.xml
          
          echo "üöÄ Submitting to Testmo..."
          echo "üîó Instance: $TESTMO_URL"
          echo "üìã Project ID: 1 (NOTE: Make sure this matches your actual project ID)"
          
          # Submit results to Testmo regardless of test success/failure
          # NOTE: Adjust --project-id to match your Testmo project ID
          if testmo automation:run:submit \
            --instance "$TESTMO_URL" \
            --project-id 1 \
            --name "Maestro iOS Tests - ${{ github.event.inputs.project_name }} - PR #${{ github.event.inputs.pr_number }}" \
            --source "maestro-ios" \
            --resources resources.json \
            --results test-results/*.xml; then
            echo "‚úÖ Results successfully submitted to Testmo!"
          else
            echo "‚ùå Failed to submit results to Testmo"
            echo "üîç Checking if files exist and are readable:"
            echo "  - resources.json: $([ -f resources.json ] && echo 'exists' || echo 'missing')"
            if [ -f resources.json ]; then
              echo "üìÑ resources.json content:"
              cat resources.json
            fi
            exit 1
          fi
        env:
          TESTMO_URL: ${{ secrets.TESTMO_URL }}
          TESTMO_TOKEN: ${{ secrets.TESTMO_TOKEN }}

      - name: Check Test Results
        if: always()
        run: |
          echo "üîç Final test results check..."
          
          echo "üìä Environment status:"
          echo "  - TESTMO_ENABLED: $TESTMO_ENABLED"
          echo "  - TEST_EXIT_CODE: $TEST_EXIT_CODE"
          
          if [ "$TESTMO_ENABLED" = "true" ]; then
            echo "‚úÖ Testmo integration was enabled - results should be available in Testmo"
            echo "üîó Check your Testmo instance for the submitted results"
          elif [ "$TESTMO_ENABLED" = "false" ]; then
            echo "‚ùå Testmo integration was disabled due to configuration issues"
            echo "üí° Check the 'Validate Testmo Configuration' step above for details"
          else
            echo "‚ö†Ô∏è  Testmo integration status unknown"
            echo "üí° To enable Testmo integration, configure TESTMO_URL and TESTMO_TOKEN secrets"
          fi
          
          # Show where results are available locally
          if [ -f "test-results/maestro-junit.xml" ]; then
            echo "üìÑ JUnit XML results generated: test-results/maestro-junit.xml"
            echo "üìä Test summary from JUnit XML:"
            grep -o 'tests="[^"]*"' test-results/maestro-junit.xml || echo "Could not parse test count"
            grep -o 'failures="[^"]*"' test-results/maestro-junit.xml || echo "Could not parse failure count"
            echo "üíæ Artifact uploads are currently disabled (to save storage quota)"
          else
            echo "‚ùå No JUnit XML results found"
          fi
          
          # Exit with the original test exit code to preserve workflow status
          if [ -n "$TEST_EXIT_CODE" ] && [ "$TEST_EXIT_CODE" != "0" ]; then
            echo "‚ùå Tests failed with exit code $TEST_EXIT_CODE"
            exit $TEST_EXIT_CODE
          else
            echo "‚úÖ All tests passed"
          fi
          
      # Artifact uploads disabled to save storage quota during testing
      # Uncomment these steps when you need to debug test issues
      
      # - name: Upload JUnit Test Results
      #   if: always()
      #   uses: actions/upload-artifact@v4
      #   with:
      #     name: maestro-ios-junit-results-${{ github.run_number }}
      #     path: |
      #       test-results/*.xml
      #       test-results/**/*.xml
      #     retention-days: 30

      # - name: Upload Test Reports
      #   if: always()
      #   uses: actions/upload-artifact@v4
      #   with:
      #     name: maestro-ios-test-reports-${{ github.run_number }}
      #     path: |
      #       ~/.maestro/tests/**/*
      #       **/test-results/**
      #       **/maestro-results/**
      #     retention-days: 30
          
      # - name: Upload Debug Artifacts (Screenshots & Logs)
      #   if: always()
      #   uses: actions/upload-artifact@v4
      #   with:
      #     name: maestro-ios-debug-artifacts-${{ github.run_number }}
      #     path: |
      #       ~/.maestro/tests/**/screenshots/**
      #       ~/.maestro/tests/**/logs/**
      #       ~/.maestro/tests/**/*.png
      #       ~/.maestro/tests/**/*.jpg
      #       ~/.maestro/tests/**/*.log
      #       ~/.maestro/tests/**/*.xml
      #       ~/.maestro/tests/**/*.json
      #     retention-days: 30
          
      - name: Generate Test Summary
        if: always()
        run: |
          echo "# üß™ Maestro iOS Test Results Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üìä Test Execution Overview" >> $GITHUB_STEP_SUMMARY
          echo "- **Workflow Run**: #${{ github.run_number }}" >> $GITHUB_STEP_SUMMARY
          echo "- **IPA**: ${{ github.event.inputs.ipa_artifact_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Project**: ${{ github.event.inputs.project_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **PR**: #${{ github.event.inputs.pr_number }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Simulator**: ${{ github.event.inputs.simulator_device }}" >> $GITHUB_STEP_SUMMARY
          
          # Add Testmo integration status
          if [ "$TESTMO_ENABLED" = "true" ]; then
            echo "- **Testmo Integration**: ‚úÖ Enabled - Results submitted to Testmo" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **Testmo Integration**: ‚ö†Ô∏è Disabled - Configure TESTMO_URL and TESTMO_TOKEN secrets to enable" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "## üóÇÔ∏è Debug Artifacts Available" >> $GITHUB_STEP_SUMMARY
          echo "The following debug artifacts have been uploaded:" >> $GITHUB_STEP_SUMMARY
          echo "- üì± **Screenshots**: UI state at each test step" >> $GITHUB_STEP_SUMMARY
          echo "- üìã **Logs**: Detailed execution logs" >> $GITHUB_STEP_SUMMARY
          echo "- üîç **Test Reports**: Complete test results" >> $GITHUB_STEP_SUMMARY
          echo "- üìä **UI Hierarchy**: Element structure for debugging" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Count debug directories
          DEBUG_DIRS=$(find ~/.maestro/tests -type d -name "*2025*" 2>/dev/null | wc -l)
          echo "## üìÅ Debug Output Locations" >> $GITHUB_STEP_SUMMARY
          echo "Found **$DEBUG_DIRS** test execution(s) with debug output:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # List debug directories with details
          if [ "$DEBUG_DIRS" -gt 0 ]; then
            find ~/.maestro/tests -type d -name "*2025*" 2>/dev/null | while read dir; do
              TEST_NAME=$(basename "$(dirname "$dir")" 2>/dev/null || echo "Unknown")
              TIMESTAMP=$(basename "$dir")
              SCREENSHOT_COUNT=$(find "$dir" -name "*.png" 2>/dev/null | wc -l)
              echo "### üß™ Test: $TEST_NAME" >> $GITHUB_STEP_SUMMARY
              echo "- **Timestamp**: $TIMESTAMP" >> $GITHUB_STEP_SUMMARY
              echo "- **Screenshots**: $SCREENSHOT_COUNT files" >> $GITHUB_STEP_SUMMARY
              echo "- **Path**: \`$dir\`" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
            done
          fi
          
          echo "## üîó How to Access Debug Files" >> $GITHUB_STEP_SUMMARY
          echo "1. Go to the **Actions** tab of this repository" >> $GITHUB_STEP_SUMMARY
          echo "2. Click on this workflow run" >> $GITHUB_STEP_SUMMARY
          echo "3. Scroll down to **Artifacts** section" >> $GITHUB_STEP_SUMMARY
          echo "4. Download the artifacts you need:" >> $GITHUB_STEP_SUMMARY
          echo "   - üìä \`maestro-ios-test-reports-${{ github.run_number }}\` - Complete test results" >> $GITHUB_STEP_SUMMARY
          echo "   - üñºÔ∏è \`maestro-ios-debug-artifacts-${{ github.run_number }}\` - Screenshots & logs" >> $GITHUB_STEP_SUMMARY
